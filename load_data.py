import h5py
import numpy as np
import scipy.io
import cv2


def load_ground_truth_generation_data(path):
    """
    Loads ground truth data generated by MATLAB annotation tool.

    Returns:
        filters_binary
        600 x 500 x 500 bool

        events_in_frames
        11998 x {eventsInThisFrame} int

        events_for_filters
        600 x {eventsForThisFilter} int

        filter_centroids
        600 x 2 int
    """
    ground_truth_generation_data = scipy.io.loadmat(path)

    # 600 x 500 x 500 bool
    filters_binary = ground_truth_generation_data["filtersBinary"]
    filters_binary = np.array(
        [
            np.array(filters_binary[:, :, i]).transpose()
            for i in range(np.shape(filters_binary)[2])
        ],
        dtype=np.bool,
    )

    # 11998 x {eventsInThisFrame} int
    events_in_frames = ground_truth_generation_data["eventsInFrames"]
    events_in_frames = np.array(
        [events_in_frames[0, i][0] - 1 for i in range(np.shape(events_in_frames)[1])], dtype=object
    )

    # 600 x {eventsForThisFilter} int
    events_for_filters = ground_truth_generation_data["eventsForFilters"]
    events_for_filters = np.array(
        [
            events_for_filters[0, i][0] - 1
            for i in range(np.shape(events_for_filters)[1])
        ]
        , dtype=object
    )

    # 600 x 2 int
    filter_centroids = ground_truth_generation_data["filterCentroids"]
    filter_centroids = [[y, x] for [x, y] in filter_centroids]
    return [filters_binary, events_for_filters, filter_centroids, events_in_frames]


def load_cell_map(map_path, annotation_type):
    if annotation_type == "pca_ica":
        cell_map = scipy.io.loadmat(map_path)
        return cell_map["cellMap"]
    if annotation_type == "cnmf-e":
        cell_map = scipy.io.loadmat(map_path)
        return cell_map["cellmap"]
    if annotation_type == "min1pipe":
        pass


def load_annotation_data(annotation_path, annotation_type):
    if annotation_type == "pca_ica":
        pca_ica = load_ground_truth_generation_data(annotation_path)
        return pca_ica
    if annotation_type == "cnmf-e":
        pass


def load_cnmfe_coord(coordinates_path):

    coordinates = scipy.io.loadmat(coordinates_path)
    coord = coordinates["coords"]
    coords_all = []
    for i in range(coord.shape[0]):
        coords = []
        for x in range(len(coord[i][0][0])):
            c_x = coord[i][0][0][x]
            c_y = coord[i][0][1][x]

            coords.append([c_x, c_y])

        coords.append(coords[0])
        coords_all.append(coords)

    return np.array(coords_all, dtype=object)

def find_contours_from_binary_mask(im):
    im = im.astype(int)
    im *= 255
    im = np.uint8(im)
    kernel = np.ones((2,2),np.uint8)
    opening = cv2.morphologyEx(im, cv2.MORPH_OPEN, kernel)
    closing = cv2.morphologyEx(opening, cv2.MORPH_CLOSE, kernel)
    _, contours, _ = cv2.findContours(closing, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    return contours

def apply_two_third_filter(weighted_masks_path):
    weighted_masks = scipy.io.loadmat(weighted_masks_path)
    binary_masks_two_third = np.zeros(( weighted_masks["A"].shape[2], 500, 500))
    for l in range(weighted_masks["A"].shape[2]):
        if np.max(weighted_masks["A"][:, :, l]) >= 0.5:
            threshold = np.max(weighted_masks["A"][:, :, l]) * 1/3
        for i in range(0, 500):
            for j in range(0, 500):
                value = weighted_masks["A"][i, j, l]
                if value >= threshold:
                    binary_masks_two_third[l, j, i] = 1

    return binary_masks_two_third

def get_coord_from_binary(masks, key="pca-ica"):

    contours_all = []
    index_del = []
    for i in range(masks.shape[0]):
        mask = masks[i]
        contours = find_contours_from_binary_mask(mask)
        if contours:
            contours_new= []
            for j, contour in enumerate(contours[0]):

                x = contour[0][0]
                y = contour[0][1]
                if x != 0 and x != 500:
                    x_new = contour[0][0] - 2
                else:
                    x_new = x
                if y != 0 and y != 500:
                    y_new = contour[0][1] - 2
                else:
                    y_new = y
                contours_new.append([[x_new, y_new]])

            contours_all.append([contours_new])
        else:
            index_del.append(i)

    contours_all = np.array(contours_all, dtype=object)

    coords_all_pca = []

    for i in range(contours_all.shape[0]):
        coord = []
        for j in range(len(contours_all[i][0])):
            x = contours_all[i][0][j][0][1]
            y = contours_all[i][0][j][0][0]
            coord.append([x, y])

        coord.append(coord[0])
        coords_all_pca.append(coord)

    coords_all_pca = np.array(coords_all_pca, dtype=object)
    return coords_all_pca, index_del


def load_preprocessed_movie(movie_path):
    movie = h5py.File(movie_path, 'r')
    return movie['1']
